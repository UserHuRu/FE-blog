step 1- 为什么前端需要模块化？

 问题 全局变量命名冲突：原始的前端，js文件是共享作用域的。当想在多个js文件之间通讯是，可能会把一个变量挂在到window上，变成 一个全局变量。当全局变量很多时，容易出现命名冲突，很难维护。
 => 要限制作用域，并且 移除全局变量
 问题： js文件间依赖关系混乱问题。
 => 通过规定一些特殊的语法，来在代码中声明依赖关系，再开发一个工具来自动化处理文件之间的依赖，就可以解决依赖混乱的问题
 以上做法我们称为 模块化。
 => 代码需要分离成小块，以便能为人所理解。分离。
 => 在一个文件中编码，被许多其他文件重复使用。这提高代码的复用性

 我们把每一个 .js 文件都视为一个 模块，
 模块内部有自己的作用域，不会影响到全局。
 约定一些关键词来进行依赖声明和 API 暴露。这些约定的关键词就是通过制定一些 规范 去进行规范的
 
 ------------元气满满-------CommonJS-----------
 目前模块化规范有：CMD、AMD、CommonJS 和 ES6 Module
 
CommonJS 由于是被 NodeJS 所采用的，所以很多人用；
ES6 Module 自然是ECMAScript 2015 所采用的了，以后会逐渐成为最主要的模块化规范；

=> CommonJS语法
module.exports = {
  bar: 123
}

require('foo.js') // 返回 { bar: 123 }

描述：
  · 同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快。
  · 一个文件就是一个模块，每个模块都是单独的作用域，除非定义为global对象的属性
  · 只能在运行时确定
  · 模块加载的顺序，按照其在代码中出现的顺序
  · require 命令第一次执行的时候，会加载并执行整个脚本，然后在内存中生成此脚本返回的 exports 对象。
  · 第二次调用某个模块的时候，就会从 exports 中取值，
    即使再执行，也不会再执行该模块，而是从缓存中取值，返回的是第一次运行的结果，除非手动清除缓存。

    // 删除指定模块的缓存
    delete require.cache[moduleName];

    // 删除所有模块的缓存
    Object.keys(require.cache).forEach(function(key) {
      delete require.cache[key];
    })

    · 缓存是根据绝对路径识别模块的，如果同一个模块放在不同的路径下，还是会重新加载这个模块

------------元气满满-------ES6 Module-------------

ES6 Module 旨在成为浏览器和服务器通用的模块解决方案.
设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量
=> ES6 Module语法

// math.js
export { basicNum, add }
或
export default { basicNum, add }

// 引用方式
import { basicNum, add } from './math';
或
import math from './math'

描述： 
· import 命令具有提升效果，会提升到整个模块的头部，首先执行。
· 同步、异步加载均可，所以ES6 模块在浏览器和服务器端都可以用。
· ES6 模块遇到 import 命令时，不会去执行模块，而是生成一个引用，等用到的时候，才去模块中取值。因为是动态引用，所以不存在缓存的问题。

--------------元气满满-------ES6 模块与 CommonJS 模块的差异----------------------
· CommonJS 模块输出的是值的拷贝
· CommonJS 模块是运行时加载

· ES6 Module 输出的是值的引用。
· ES6 Module 是编译时输出接口
· ES6 模块是动态引用，并且不会缓存值.（ES6 模块在对脚本静态分析的时候，遇到 import 就会生成一个只读引用，等到脚本真正执行的时候，再根据这个只读引用，到被加载的那个模块里取值，所以说 ES6 模块是动态引用）

------------元气满满----------题外话--------------

只读：不可重新赋值，可以新增属性
